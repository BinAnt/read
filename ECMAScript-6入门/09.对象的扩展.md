## 对象的扩展



#### 1.属性的简洁表示法

ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。

~~~js
const foo = 'bar';
const baz = {foo};
baz // {foo: "bar"}

// 等同于
const baz = {foo: foo};
~~~

上面的代码中，变量==foo==直接写在大括号里面。属性名就是属性名，属性值就是变量值。

~~~js
function f(x, y) {
  return {x, y};
}

// 等同于

function f(x, y) {
  return {x: x, y: y};
}

f(1, 2) // Object {x: 1, y: 2}
~~~

除了属性简写，方法也可以简写。

~~~js
const o = {
    method() {
        return "Hello!";
    }
}

//等同于
const o = {
    method: function() {
        return "Hello!"
    }
}
~~~

~~~js
let birth = '2000/01/01';

const Person = {

  name: '张三',

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() { console.log('我的名字是', this.name); }

};
~~~

这种写法用于函数的返回值，将会非常方便

~~~js
function getPoint() {
  const x = 1;
  const y = 10;
  return {x, y};
}

getPoint()
// {x:1, y:10}
~~~

CommonJS 模块输出一组变量，就非常合适使用简洁写法

~~~js
let ms = {}
function getItem (key) {
  return key in ms ? ms[key] : null;
}

function setItem (key, value) {
  ms[key] = value;
}

function clear () {
  ms = {};
}

module.exports = {getItem, setItem, clear}

// 等同于
modulw.exports = {
    getItem: getItem,
    setItem: setItem,
    clear: clear
}
~~~



注意，简写的对象方法不能用作构造函数，会报错。

~~~js
const obj = {
  f() {
    this.foo = 'bar';
  }
};

new obj.f() // 报错
~~~

上面代码中，==f==是一个简写的对象方法，所以==obj.f==不能当做构造函数使用。

---



#### 2.属性名表达式

JavaScript定义对象的属性，有两种方法

~~~js
// 方法一
obj.foo = true;

// 方法二
obj['a' + 'bc'] = 123;
~~~

上面代码的方法一是直接用标识作为属性名，方法二是用表达式作为属性，这时要将表达式放在方括号内。



ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。

~~~js
let propKey = 'foo';

let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
};
~~~

~~~js
let lastWord = 'last word';

const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"
~~~

表达式还可用于定义方法名。

~~~js
let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};

obj.hello() // hi
~~~

注意：

1. 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串==[object Object]==, 这一点要特别小心

   ~~~js
   const keyA = {a: 1};
   const keyB = {b: 2};
   
   const myObject = {
     [keyA]: 'valueA',
     [keyB]: 'valueB'
   };
   
   myObject // Object {[object Object]: "valueB"}
   ~~~

上面代码中，==[keyA]==和==[keyB]==得到的都是==[object Object]==,所以==[keyB]==会把==[keyA]==覆盖掉，而==myObject==最后只有一个==[object Object]==属性。

---



#### 3.方法的 name 属性

函数的==name==属性，返回函数名。对象方法也是函数，因此也有==name==属性

~~~js
const person = {
  sayName() {
    console.log('hello!');
  },
};

person.sayName.name   // "sayName"
~~~

上面代码中，方法的==name==属性返回函数名（即方法名）。



如果对象的方法使用了取值函数（==getter==）和存值函数（==setter==），则==name==属性不是再该方法上面，而是该方法的属性的描述对象的==set==和==get==属性上面，返回值是方法名前加上==set==和==get==。

~~~js
const obj = {
  get foo() {},
  set foo(x) {}
};

obj.foo.name
// TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

descriptor.get.name // "get foo"
descriptor.set.name // "set foo"
~~~

---



#### 4.属性的可枚举和遍历

对象的每个属性都有一个描述对象（Descriptor），用来控制改属性的行为。



#### 5.super 关键字

#### 6.对象的扩展运算符

#### 7.链判断运算符

#### 8.Null 判断运算符